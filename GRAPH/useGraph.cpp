#include <iostream>

//----------------------------------------------------------------------------------------------------------------------------------------------------------------//
/*
  Объявим структуру для хранения смежной вершины в которой опишем пары: номер вершины / вес ребра.
*/
    struct _adj_list {
      int64_t _vertex_adj ; //номер вершины
      int64_t _weight ;    // вес ребра
    } ;

//----------------------------------------------------------------------------------------------------------------------------------------------------------------//
/* Все вершины графа нумеруются начиная с 0. По смыслу 0 означает вершина № 0  ; 1 вершина № 1; и т.д.. */

/*
  Создадим массив структур struct _adj_list _array,  тип массива _adj_list в котором опишем пары: номер вершины / вес ребра.
  По смыслу это массив смежных вершин

*/
  struct _adj_list _array [4] = { {1, 2}, {2, 4}, {3, 8}, {4, 7} } ;
//----------------------------------------------------------------------------------------------------------------------------------------------------------------//
/*
  Создадим вспомогательный массив int64_t _sub_array, тип массива int64_t, в котором опишем количество смежных вершин:
    например для элемента _sub_array [0] ( по смыслу для вершины № 0 ) смежных вершин 2; для элемента _sub_array [1] ( по смыслу для вершины № 1 ) смежных вершин 3;
    и т.д...
*/
  int64_t _sub_array [2] = { 2, 2 } ;
//----------------------------------------------------------------------------------------------------------------------------------------------------------------//
/*
  Опишем функцию инициализации ( построения ) графа:
*/

  _adj_list** Initialization ( const struct _adj_list *_array,    const int64_t &_size_of_array,
                               const int64_t          *_sub_array, const int64_t &_size_of_sub_array ) {
  //---------------------------------------------------------------------------------------------------------------------------------------//
    /*Член класса*/   // Создаем указатель для храниния инициализированного графа ( возвращаемое значение ) ;
    _adj_list **_graph = nullptr ;
  //---------------------------------------------------------------------------------------------------------------------------------------//
    /*Выделение в конструкторе класса*/
    _graph = new _adj_list* [_size_of_array] ;
  //---------------------------------------------------------------------------------------------------------------------------------------//
    /*Освобождение памяти в деструкторе класса*/
    //for( int64_t i = 0 ; i < _size_of_array ; i++ ) delete _graph[i] ; delete []_graph ;
  //---------------------------------------------------------------------------------------------------------------------------------------//
//TODO : необходима дополнительная проверка чтобы не вылететь за границы массива : struct _adj_list& *_array или оставить на совести
//  пользователя корректность ввода данных в массив.

    int64_t _step = 0 ;
    for( int64_t i = 0 ; i < _size_of_sub_array ; i++ ) {
      std::cout << std::endl ;
      std::cout << "Вершина № " << i << " : \n";
      _graph[i] = new _adj_list[_sub_array[i]] ;

      for( int64_t j = 0 ;  j < _sub_array[i] ; j++ ) {
        _graph[i][j]._vertex_adj = _array[_step]._vertex_adj ;
        _graph[i][j]._weight     = _array[_step++]._weight     ;
        std::cout <<"   \t соединена ребром весом " << _graph[i][j]._weight << " со смежной вершиной № " << _graph[i][j]._vertex_adj << " \n" ;
      }
    }
  return _graph ;
  }


int main () {

  struct _adj_list _array [6] = { {1, 9}, {2, 8}, {3, 7}, {4, 6}, {0, 5}, {0, 4} } ;
  const int64_t _size_of_array = sizeof( _array ) / sizeof( *_array ) ;

  int64_t _sub_array [5] = { 1, 1, 1, 2, 1 } ;
  const int64_t _size_of_sub_array = sizeof( _sub_array ) / sizeof( *_sub_array ) ;


  _adj_list **_graph = Initialization ( _array, _size_of_array, _sub_array, _size_of_sub_array ) ;


  for( int64_t i = 0 ; i < _size_of_array ; i++ ) delete _graph[i] ; delete []_graph ;

return 0 ;
}
